{\rtf1\ansi\deflang1024\deff0{\fonttbl{\f0\froman Times Roman;}{\f1\fnil Times;}}{\colortbl;\red0\green0\blue0;\red0\green0\blue255;}{\stylesheet{\f1\fs24\cf1 \snext0 Normal;}{\s1 \f1\fs24\cf1 \sbasedon0\snext1 Cell;}{\s2 \f1\fs24\cf1 \sbasedon0
\snext2 Footnote;}{\s3\tqc\tx5040\tqr\tx10080\tqr\tx13680 \f1\fs24\cf1 \sbasedon0\snext3 HdrFtr;}{\s4 \ul\f1\fs24\cf2 \sbasedon0\snext4 html_hyperlink_text;}}
{\info{\title ax06550j.aw}{\author cjl}{\doccomm Created by ApplixWare Release 4.41 (build 1021.211.13) #17  RTF Export Filter}}
\paperw12240\paperh15840\margl1080\margr1080\margt1440\margb1440\widowctrl\ftnbj\sectd\marglsxn1080\margrsxn1080\margtsxn1440\margbsxn1440\sbknone\headery360\footery360\endnhere\pard\plain \qc \f1\fs24\cf1 {\b\ul\fs36 Notes on Mk4 software directory 
structures and utility routines}
\par \pard\plain \f1\fs24\cf1 
\par \pard\plain \qc \f1\fs24\cf1 Modified by CJL, 31 March 1999
\par \pard\plain \f1\fs24\cf1 
\par There is a pair of shell scripts in /correlator/prog which, when executed, should set up the various environment variables referred to in my document of March 23 on the directory structure.  The shell scripts are called {\b mk4_setup.csh} and {
\b mk4_setup.sh} for csh (and derivatives) and sh (and derivatives) respectively.
\par 
\par Before these scripts are executed, the ARCH environment variable must be set (currently only "linux" and "hppa" are supported).
\par 
\par In the UTIL library ($UTIL/$ARCH/libutil.a) there is a routine called {\b environment()}{, which initializes several external character strings with corresponding environment variable settings.  If an environment variable is undefined, the string 
is set to a default value by }{\b environment()}{.  There are no arguments.  To use this routine, simply call it at the start of your program.  By declaring the strings as externs, they can be accessed in any subroutine.  Their names, and the environment 
variables they correspond to are:}
\par 
\par \tab datadir\tab DATADIR
\par \tab scheddir\tab SCHEDDIR
\par \tab afiledir\tab AFILEDIR
\par \tab textdir\tab\tab TEXT
\par \tab sysvexdir\tab SYSVEX
\par \tab taskdir\tab\tab TASK
\par \tab bindir\tab\tab BIN
\par \tab tmpdir\tab\tab TMP
\par 
\par so if you need file "xyz" in the sysvex directory, you might use code something like this:
\par 
\par ...
\par ...
\par main()
\par ...
\par ...
\par environment();
\par ...
\par ...
\par void thisfunction()
\par     \{
\par     extern char sysvexdir[];
\par     char rel_filename[] = "xyz";
\par 
\par     sprintf (filename, "%s/%s", sysvexdir, rel_filename);
\par ...
\par 
\par \page I have constructed the routine {\b emsg()}{ discussed by Roger.  The logical place for it is in $MESS (=$CORRSUB/mess), which will also contain mess.c.  The }{\b emsg() }{call is used only by the online Mk4 system, so belongs in the $CORR 
tree, not in $UTIL.  A small makefile will be needed to build a libmess.a library archive for linking, containing emsg.o and mess.o.  The source code only is currently in $MESS, pending JAB's transferral and suitable modification of mess.c and mess.h.}
\par 
\par The routine has a variable argument list just like {\b printf()}, is called in the same way, and does the same formatting as {\b printf}.  There are, however, two additional arguments immediately after the format string, namely {\b level} and {
\b errnum}.
\par 
\par The first is an importance level argument for verbosity control.  There is an extern int called {\b error_level}, declared in {\b emsg.c}, which defaults to 0.  If the {\b level} argument in the call to {\b emsg()} equals or exceeds {\b error_level}, 
the error message gets sent to the appropriate target program or programs (see below), otherwise nothing happens.  Normally, various fatal and non-fatal error conditions would be coded with different {\b level} argument values.  The value of the {\b error_level} 
extern can be manipulated by a command line flag, a message sent from another program, or both, in order to control the verbosity of the error message stream generated by the program.
\par 
\par The second extra argument is composed of two parts.  The first is a unique error number, which acts as a key into a file of descriptive error messages of arbitrary length.  Defines for these error numbers will be provided in the header file $INC/mk4_errno.h. 
 Also in this header file are {\b #define} statements for bits corresponding to various programs in the online system.  These bits can be OR'ed into the {\b emsg} argument in order to specify the destination(s) for the error message.  If no destination 
bits are set, {\b emsg} defaults to sending the message to opera.
\par 
\par The routine prepends the name of the program to each message.  This name is contained in the extern character string {\b emsg_progname}, which has a frivolous default.  Programs which use {\b emsg} should reset this extern to a sensible value upon 
startup.
\par 
\par A typical call might be:
\par 
\par #include "mk4_errno.h"
\par 
\par \tab if (error)
\par \tab\tab\{
\par \tab\tab emsg ("Tape drive number %d has exploded - check for casualties", 
\par \tab\tab\tab\tab\tab\tab\tab 2, BANG | CONDUCTOR, driveno);
\par \tab\tab return (-1);
\par \tab\tab\}
\par }
